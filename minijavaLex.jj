options {
    IGNORE_CASE = false;
    LOOKAHEAD=3;
}

PARSER_BEGIN(minijavaParser)

import java.io.*;

public class minijavaParser {

    public static void main(String[] args) throws FileNotFoundException, ParseException, TokenMgrError{
        minijavaParser parser = new minijavaParser( System.in ) ;
        parser.Start() ;

        if (args.length < 1) {
            System.out.println("Please pass in the filename for a parameter.");
            System.exit(1);
        }

        SimpleCharStream stream = new SimpleCharStream(new FileInputStream(args[0]), 0, 0);
        Token temp_token = null;

        minijavaLexTokenManager TkMgr = new minijavaLexTokenManager(stream);
    }
}

PARSER_END(minijavaLex)

void Start()
{}
{
    program()
    <EOF>
}

SKIP: {
    "\t"
    | "\r"
    | " "
    | "\n"
    | <COMMENT: <SINGLE_LINE_COMMENT> >
}

SKIP :
{
  "/*" : WithinComment
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}

TOKEN: {
    < #LETTER : ["a"-"z", "A"-"Z"] >
    | < #DIGIT : (["0"-"9"])+ >
}

TOKEN: {
    <AND: "&&">
    | <LESS_THAN: "<">
    | <PLUS: "+">
    | <MINUS: "-">
    | <MULTIPLY: "*">
    | <CLASS: "class">
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <INT: "int">
    | <RETURN: "return">
    | <BOOLEAN: "boolean">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <PRINT: "System.out.println">
    | <LENGTH: "length">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <LPARENS: "(">
    | <RPARENS: ")">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <ASSIGN: "=">
    | <SEMI_COMMA: ";">
    | <COMMA: ",">
    | <NEGATE: "!">
    | <L_C_BRACKET: "{">
    | <R_C_BRACKET: "}">
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | <INTEGER_LITERAL: <DIGIT>>
    | <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | <OTHER: ~[] >
}

void NonCombinatoryExp() :
 {}
 {
    <INTEGER_LITERAL>
   | <TRUE>
   | <FALSE>
   | <IDENTIFIER>
   | <THIS>
   | <NEW> <INT> <LBRACKET> Exp() <RBRACKET>
   | <NEW> <IDENTIFIER> <LPARENS> <RPARENS>
   | <NEGATE> Exp()
   | <LPARENS> Exp() <RPARENS>
 }

 void Exp():
 {}
 {
     NonCombinatoryExp() Exp()
    | NonCombinatoryExp() <PLUS> Exp()
    | NonCombinatoryExp() <MULTIPLY> Exp()
    | NonCombinatoryExp() <LBRACKET> Exp() <RBRACKET>
    | NonCombinatoryExp() <DOT> <LENGTH>
    | NonCombinatoryExp() <DOT> <IDENTIFIER> <LPARENS> ExpList() <RPARENS>
  }

void ExpRest():
{}
{
    ", " Exp()
}

void ExpList() :
 {}
 {
    Exp() {ExpRest()}* | ""
 }



void Program():
{}
{
    MainClass
    {ClassDecl}*
}

